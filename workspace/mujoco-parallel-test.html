<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MuJoCo Parallel Environments Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #333;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button {
            margin: 0 10px;
            padding: 10px 20px;
            font-size: 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .info {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
            text-align: center;
        }
        
        .environments {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .env-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .env-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        canvas {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            background: #fafafa;
        }
        
        .env-info {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MuJoCo Parallel Environments Test</h1>
        
        <div class="controls">
            <button id="initBtn" onclick="initTest()">Initialize Test</button>
            <button id="stepBtn" onclick="stepAll()" disabled>Step All</button>
            <button id="runBtn" onclick="runContinuous()" disabled>Run Continuous</button>
            <button id="stopBtn" onclick="stopContinuous()" disabled>Stop</button>
            <button id="resetBtn" onclick="resetAll()" disabled>Reset All</button>
        </div>
        
        <div class="info" id="info">
            Click "Initialize Test" to load MuJoCo and create parallel environments
        </div>
        
        <div id="environments" class="environments"></div>
        
        <div class="log" id="log">
            <strong>Log:</strong><br>
        </div>
    </div>

    <script>
        // Configuration
        const NUM_ENVIRONMENTS = 4;
        const WORKER_SCRIPT = `
            // Inline worker code for MuJoCo simulation
            let mujoco = null;
            let model = null;
            let state = null;
            let simulation = null;
            
            self.onmessage = async function(e) {
                const { type, data } = e.data;
                
                switch(type) {
                    case 'init':
                        try {
                            // Import MuJoCo
                            importScripts('/dist/mujoco_wasm.js');
                            mujoco = await load_mujoco();
                            
                            // Set up filesystem
                            mujoco.FS.mkdir('/working');
                            mujoco.FS.mount(mujoco.MEMFS, { root: '.' }, '/working');
                            
                            self.postMessage({ type: 'initialized', success: true });
                        } catch (error) {
                            self.postMessage({ type: 'initialized', success: false, error: error.message });
                        }
                        break;
                        
                    case 'loadModel':
                        try {
                            // Write XML to filesystem
                            mujoco.FS.writeFile('/working/model.xml', data.xml);
                            
                            // Load model
                            model = new mujoco.Model('/working/model.xml');
                            state = new mujoco.State(model);
                            simulation = new mujoco.Simulation(model, state);
                            
                            self.postMessage({ type: 'modelLoaded', success: true });
                        } catch (error) {
                            self.postMessage({ type: 'modelLoaded', success: false, error: error.message });
                        }
                        break;
                        
                    case 'step':
                        try {
                            if (!simulation) throw new Error('Simulation not initialized');
                            
                            // Apply controls if provided
                            if (data.controls) {
                                for (let i = 0; i < data.controls.length; i++) {
                                    simulation.ctrl[i] = data.controls[i];
                                }
                            }
                            
                            // Step simulation
                            simulation.step();
                            
                            // Get state
                            const stateData = {
                                time: simulation.time,
                                qpos: Array.from(simulation.qpos),
                                qvel: Array.from(simulation.qvel)
                            };
                            
                            self.postMessage({ type: 'stepped', data: stateData });
                        } catch (error) {
                            self.postMessage({ type: 'stepped', error: error.message });
                        }
                        break;
                        
                    case 'reset':
                        try {
                            if (simulation) {
                                simulation.reset();
                                self.postMessage({ type: 'resetDone', success: true });
                            }
                        } catch (error) {
                            self.postMessage({ type: 'resetDone', success: false, error: error.message });
                        }
                        break;
                        
                    case 'render':
                        try {
                            if (!simulation) throw new Error('Simulation not initialized');
                            
                            // Get render data (simplified)
                            const positions = simulation.xpos;
                            const renderData = {
                                bodies: []
                            };
                            
                            // Extract body positions (every 3 values is x,y,z)
                            for (let i = 0; i < positions.length; i += 3) {
                                renderData.bodies.push({
                                    x: positions[i],
                                    y: positions[i + 1],
                                    z: positions[i + 2]
                                });
                            }
                            
                            self.postMessage({ type: 'renderData', data: renderData });
                        } catch (error) {
                            self.postMessage({ type: 'renderData', error: error.message });
                        }
                        break;
                }
            };
        `;
        
        // Global state
        let workers = [];
        let environments = [];
        let isRunning = false;
        let animationId = null;
        
        function log(message) {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${timestamp}] ${message}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        async function initTest() {
            log('Starting initialization...');
            document.getElementById('initBtn').disabled = true;
            document.getElementById('info').textContent = 'Initializing MuJoCo environments...';
            
            try {
                // Create worker blob
                const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                
                // Create workers
                for (let i = 0; i < NUM_ENVIRONMENTS; i++) {
                    const worker = new Worker(workerUrl);
                    const env = {
                        id: i,
                        worker: worker,
                        canvas: null,
                        ctx: null,
                        state: null
                    };
                    
                    // Set up message handler
                    worker.onmessage = (e) => handleWorkerMessage(i, e);
                    
                    workers.push(worker);
                    environments.push(env);
                }
                
                // Create UI for each environment
                createEnvironmentUI();
                
                // Initialize all workers
                const initPromises = workers.map((worker, i) => {
                    return new Promise((resolve, reject) => {
                        const handler = (e) => {
                            if (e.data.type === 'initialized') {
                                worker.removeEventListener('message', handler);
                                if (e.data.success) {
                                    log(`Worker ${i} initialized successfully`);
                                    resolve();
                                } else {
                                    reject(new Error(e.data.error));
                                }
                            }
                        };
                        worker.addEventListener('message', handler);
                        worker.postMessage({ type: 'init' });
                    });
                });
                
                await Promise.all(initPromises);
                
                // Load a simple model in each worker
                await loadModels();
                
                // Enable controls
                document.getElementById('stepBtn').disabled = false;
                document.getElementById('runBtn').disabled = false;
                document.getElementById('resetBtn').disabled = false;
                document.getElementById('info').textContent = 
                    `${NUM_ENVIRONMENTS} environments ready. Click "Step All" or "Run Continuous" to start simulation.`;
                    
                log('All environments initialized successfully!');
                
            } catch (error) {
                log(`Error during initialization: ${error.message}`);
                document.getElementById('info').textContent = 'Initialization failed. Check console for details.';
            }
        }
        
        function createEnvironmentUI() {
            const container = document.getElementById('environments');
            container.innerHTML = '';
            
            for (let i = 0; i < NUM_ENVIRONMENTS; i++) {
                const envDiv = document.createElement('div');
                envDiv.className = 'env-container';
                envDiv.innerHTML = `
                    <div class="env-header">Environment ${i}</div>
                    <canvas id="canvas${i}" width="400" height="300"></canvas>
                    <div class="env-info" id="info${i}">Time: 0.00s</div>
                `;
                container.appendChild(envDiv);
                
                // Store canvas reference
                environments[i].canvas = document.getElementById(`canvas${i}`);
                environments[i].ctx = environments[i].canvas.getContext('2d');
            }
        }
        
        async function loadModels() {
            // Simple pendulum model for testing
            const modelXML = `
                <mujoco>
                    <worldbody>
                        <body name="pendulum" pos="0 0 1">
                            <joint name="swing" type="hinge" axis="0 1 0"/>
                            <geom name="mass" type="sphere" size="0.1" rgba="1 0 0 1"/>
                        </body>
                    </worldbody>
                    <actuator>
                        <motor joint="swing" ctrlrange="-2 2"/>
                    </actuator>
                </mujoco>
            `;
            
            const loadPromises = workers.map((worker, i) => {
                return new Promise((resolve, reject) => {
                    const handler = (e) => {
                        if (e.data.type === 'modelLoaded') {
                            worker.removeEventListener('message', handler);
                            if (e.data.success) {
                                log(`Model loaded in worker ${i}`);
                                resolve();
                            } else {
                                reject(new Error(e.data.error));
                            }
                        }
                    };
                    worker.addEventListener('message', handler);
                    
                    // Add slight variation to each environment
                    const variedXML = modelXML.replace('pos="0 0 1"', 
                        `pos="${0.1 * i} 0 ${1 + 0.1 * i}"`);
                    
                    worker.postMessage({ 
                        type: 'loadModel', 
                        data: { xml: variedXML }
                    });
                });
            });
            
            await Promise.all(loadPromises);
        }
        
        function handleWorkerMessage(workerId, event) {
            const { type, data, error } = event.data;
            
            if (error) {
                log(`Worker ${workerId} error: ${error}`);
                return;
            }
            
            switch(type) {
                case 'stepped':
                    environments[workerId].state = data;
                    updateVisualization(workerId);
                    break;
                    
                case 'renderData':
                    // Handle render data if needed
                    break;
            }
        }
        
        function updateVisualization(envId) {
            const env = environments[envId];
            if (!env.state || !env.ctx) return;
            
            const ctx = env.ctx;
            const canvas = env.canvas;
            
            // Clear canvas
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw simple visualization
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw pendulum (simplified)
            if (env.state.qpos && env.state.qpos.length > 0) {
                const angle = env.state.qpos[0];
                const length = 100;
                
                const x = centerX + Math.sin(angle) * length;
                const y = centerY + Math.cos(angle) * length;
                
                // Draw line
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Draw mass
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Update info
            document.getElementById(`info${envId}`).textContent = 
                `Time: ${env.state.time.toFixed(2)}s | Angle: ${(env.state.qpos[0] * 180 / Math.PI).toFixed(1)}Â°`;
        }
        
        async function stepAll() {
            log('Stepping all environments...');
            
            // Send step command to all workers
            const promises = workers.map((worker, i) => {
                return new Promise((resolve) => {
                    const handler = (e) => {
                        if (e.data.type === 'stepped') {
                            worker.removeEventListener('message', handler);
                            resolve();
                        }
                    };
                    worker.addEventListener('message', handler);
                    
                    // Random control input
                    const control = Math.sin(environments[i].state?.time || 0) * 0.5;
                    worker.postMessage({ 
                        type: 'step',
                        data: { controls: [control] }
                    });
                });
            });
            
            await Promise.all(promises);
        }
        
        function runContinuous() {
            if (isRunning) return;
            
            isRunning = true;
            document.getElementById('runBtn').disabled = true;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            log('Starting continuous simulation...');
            
            async function animate() {
                if (!isRunning) return;
                
                await stepAll();
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function stopContinuous() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            document.getElementById('runBtn').disabled = false;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            log('Stopped continuous simulation');
        }
        
        async function resetAll() {
            log('Resetting all environments...');
            
            const promises = workers.map((worker) => {
                return new Promise((resolve) => {
                    const handler = (e) => {
                        if (e.data.type === 'resetDone') {
                            worker.removeEventListener('message', handler);
                            resolve();
                        }
                    };
                    worker.addEventListener('message', handler);
                    worker.postMessage({ type: 'reset' });
                });
            });
            
            await Promise.all(promises);
            
            // Clear visualizations
            environments.forEach((env, i) => {
                if (env.ctx) {
                    env.ctx.fillStyle = '#f0f0f0';
                    env.ctx.fillRect(0, 0, env.canvas.width, env.canvas.height);
                }
                document.getElementById(`info${i}`).textContent = 'Time: 0.00s';
            });
            
            log('All environments reset');
        }
    </script>
</body>
</html>
